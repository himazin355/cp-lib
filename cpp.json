{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }

	//
	// C++の構文のスニペット
	//

	"for loop[0, n)": {
		"prefix": "for",
		"body": "for(int ${1:i} = 0; ${1:i} < ${2:n}; ++${1:i}){\n    \n}\n",
		"description": "for loop[0, n)"
	},

	"for loop[1, n]": {
		"prefix": "for1",
		"body": "for(int ${1:i} = 1; ${1:i} <= ${2:n}; ++${1:i}){\n    \n}\n",
		"description": "for loop[1, n]"
	},

	"for loop n-1 to 0" : {
		"prefix": "forr",
		"body": "for(int ${1:i} = ${2:n} - 1; ${1:i} >= 0; --${1:i}){\n    \n}\n",
		"description": "for loop n-1 to 0"
	},

	"Range-based for loop" : {
		"prefix": "fore",
		"body": "for(auto && ${1:i} : ${2:a}){\n    \n}\n",
		"description": "Range-based for loop"
	},

	//
	// アルゴリズムでないスニペット(便利系)
	//

	"all" : {
		"prefix": "all",
		"body": "begin($1), end($1)",
		"description": "all"
	},

	"vector" : {
		"prefix": "ve",
		"body": "vector<$1>",
		"description": "vector"
	},

	"vector<int>" : {
		"prefix": "vi",
		"body": "vector<int>",
		"description": "vector<int>"
	},

	//
	// アルゴリズムであるスニペット
	//

	"Dijkstra" : {
		"prefix": "dijkstra",
		"body": [
			"priority_queue<pair<${1:T}, int>, vector<pair<${1:T}, int>>, greater<pair<${1:T}, int>>> que;",
			"vector<${1:T}> d(n, INF);",
			"d[${2:s}] = 0;",
			"que.push({${1:T}(0), ${2:s});",
			"",
			"while(!que.empty()){",
			"    ${1:T} c = que.top().first;",
			"    int v = que.top().second;",
			"    que.pop();",
			"    ",
			"    for(auto && e : g[v]){",
			"        if(d[e.to] > c + e.cost){",
			"            d[e.to] = c + e.cost;",
			"            que.push({d[e.to], e.to});",
			"        }",
			"    }",
			"}",
			""
		],
		"description": "dijkstra code"
	},

	"Edge": {
		"prefix": "edge",
		"body": [
			"struct Edge{",
			"    int to;",
			"    ${1:T} cost;",
			"};",
			"vector<Edge> g[${2:n}];",
			""
		],
		"description": "Edge"
	},

	"Union Find Tree" : {
		"prefix": "UF",
		// source code by Spaghetti Source [http://www.prefield.com/algorithm/container/union_find.html]
		"body": ["struct UnionFind {",
			"    vector<int> data;",
			"    UnionFind(int size) : data(size, -1) { }",
			"    bool unionSet(int x, int y) {",
			"        x = root(x); y = root(y);",
			"        if (x != y) {",
			"            if (data[y] < data[x]) swap(x, y);",
			"            data[x] += data[y]; data[y] = x;",
			"        }",
			"        return x != y;",
			"    }",
			"    bool findSet(int x, int y) {",
			"        return root(x) == root(y);",
			"    }",
			"    int root(int x) {",
			"        return data[x] < 0 ? x : data[x] = root(data[x]);",
			"    }",
			"    int size(int x) {",
			"        return -data[root(x)];",
			"    }",
			"};",
			""
		],
		"description": "Union Find Tree"
	}

} 
